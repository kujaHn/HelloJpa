# 고급 매핑
* 상속관계 매핑
  

* `@MappedSuperclass`


## 상속관계 매핑
* 객체에는 상속관계가 있지만 RDBMS에서는 상속관계가 없음.
* 하지만 `슈퍼타입-서브타입 관계`라는 모델링 기법이 객체 상속과 유사하다.  
=> `슈퍼타입-서브타입` 논리 모델을 `실제 물리모델`로 구현하는 방법은 `조인전략`, `단일 테이블 전략`, `구현 클래스마다 테이블 전략` 이 세가지가 있다.  
=> **객체의 상속 구조와 DB의 슈퍼타입-서브타입 관계를 매핑.**  
  
### 조인 전략(각각 테이블로 변환하는 방법.)
* 각각의 DB를 구현한 뒤 `Join`으로 구성. (가장 객체와 유사한 모델링.) 
* 슈퍼타입을 추상화(`abstract`) 후 `@Inheritance(strategy = InheritanceType.JOINED)`를 통해 매핑. 
* 슈퍼타입에 `@DiscriminatorColumn(name="name")`를 입력하면 슈퍼타입에 `name` 컬럼이 생성되고, 서브타입들의 이름이 파라미터로 들어온다.
    * 각 서브타입들은 `@DiscriminatorValue("name")`를 통해 `name` 컬럼 에 들어오는 파라미터들을 변경할 수 있다.
      <br></br>
* 장점
    * 테이블이 `정규화`가 되어있어 설계가 편함. (정석이라 봐도 무방함.)
    * `외래 키 참조` 및 `무결성 제약조건` 활용가능
    * 저장공간을 효율적으로 나눔.
* 단점
    * 조회시 `JOIN`을 많이 사용해 성능 저하와 조회 쿼리가 복잡. (극복 가능함.)
    * 데이터 저장시 `INSERT SQL 2번 호출` (슈퍼타입에 한번, 서브타입에 한번)
    
### 단일 테이블 전략(통합 테이블로 변환하는 방법. = 한 테이블에 모든 컬럼을 삽입)
* 슈퍼타입을 추상화(`abstract`) 후 `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`를 통해 매핑
* `@DiscriminatorColumn(name="name"), @DiscriminatorValue("name")`를 **필수로 사용**
<br></br>
* 장점
    * `JOIN`이 필요 없어, 조회 성능이 빠르다
    
* 단점
    * 자식 엔티티가 매핑한 컬럼은 모두 Null을 허용해야 함. (=> 데이터 무결성 X)
    * 단일 테이블에 모든 것을 저장하기 떄문에 테이블이 커지면 조회 성능이 오히려 느려질 수 있다.

### 구현 클래스마다 테이블 전략(서브타입 테이블로 변환하는 방법.)
* 슈퍼타입을 추상화(`abstract`) 후 `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`를 통해 매핑
* 슈퍼타입 테이블 자체가 존재하지 않고, 슈퍼타입의 컬럼들이 서브타입에 각각 들어간다.
  <br></br>
* 장점
    * 서브 타입을 명확하게 구분해서 처리할 때 효과적
    * not null 제약조건 사용 가능

* 단점
    * 여러 자식 테이블을 함께 조회할 때 성능이 느림(`UNION SQL`)
    * 자식 테이블을 통합해서 쿼리하기 어려움
    * 변경할 때 대부분을 뜯어고쳐야 함.
    * **추천하지 않는 전략임.**
    
*** 
## @MappedSuperclass
* 클래스를 만드는데 `중복되는 필드`가 계속해서 나오는 경우 고려해볼 요소(ex: id, name, createdAt/By, 등등)
* `중복되는 필드`를 가지는 슈퍼 클래스를 하나 만들고 서브클래스마다 `상속`을 받으면 된다. => 자동화 가능.


* 예시

```java
@MappedSuperclass
public abstract class BaseEntity {
  private Long id;

  private Long name;

  @Column(name = "insert_member")
  private String createdBy;

  private LocalDateTime createdAt;
  
  // getter, setter...
}
```

```java
import javax.persistence.AttributeOverride;

@Entity
@AttributeOverride({
        // 각각 이름을 바꾸고 싶은 경우 오버라이딩 가능.
    @AttributeOverride(name="id", column = @Column(name = "user_id")),
    @AttributeOverride(name="name", column = @Column(name = "user_name"))
})
public class User extends BaseEntity {

  private Long id;

  private String password;
}
```

* 주의할점
  * **상속관계 매핑이 아님!!!!!!!!!**
  * 엔티티가 아니기 때문에 테이블과 매핑이 안된다.
    * 자식(서브)클래스에 **매핑정보(속성)만 제공**
    * 조회, 검색 불가(`.find(BaseEntity) 불가능)
  * 직접 생성해서 사용할 일이 없으므로 `추상 클래스`를 권장함.
  
* 정리
  * 테이블과 관계 없이, 엔티티가 `공통으로 사용하는 매핑 정보`를 모으는 역할.
  * `@Entity` 클래스는 엔티티나 `@MappedSuperclass`로 지정한 클래스만 상속 가능.
    * @Entity : 전체 상속
    * @MappedSuperclass : 속성만 상속
  
* 추가 사항
  * `@AttributeOverride(name="id", column=@Column(name="SETTINGSID"))` : 필드는 중복되나 서브 클래스마다 컬럼명을 변경하고 싶은 경우 사용.