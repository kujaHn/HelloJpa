# 영속성 전이 (CASCADE)
* 특정 엔티티를 영속 상태로 만들 때 **연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용**. 
  * ex: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장


* 예시
  ```java
      // Parent 엔티티
      @OneToMany(mappedBy = "parent")
      private List<Child> childList = new ArrayList<>();
  
      // Child 엔티티
      @ManyToOne
      @JoinColumn(name = "parent_id")
      private Parent parent;
  ```
이렇게 연관관계 매핑이 되어있다고 했을 때, 영속상태로 만들고 싶다고 가정하자.

  ```java
  Child child1 = new Child();
  Child child2 = new Child();
  
  Parent parent = new Parent();
  parent.addChild(child1);
  parent.addChild(child2);
              
  em.persist(parent);
  em.persist(child1);
  em.persist(child2);
  
  transaction.commit();
  ```

* `parent` 중심으로 `persist`를 세번 하지 않고도 자식 엔티티(`child`)를 저장 할 수 없을까? (`parent`가 `child`를 관리)

* 해결 : `cascade = CascadeType.ALL`을 추가.
    ```java
        // Parent 엔티티
        @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
        private List<Child> childList = new ArrayList<>();
    ```

## 주의 사항
* 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.
* 엔티티를 영속화할 떄 연관된 엔티티도 함께 영속화하는 **편리함을 제공할 뿐**
* `하나의 부모`가 `여러 자식`을 관리할때 유용하지, `여러 부모`가 `여러 자식`을 관리할때는 사용해서는 안된다.
  * 예시 : `parent`, `child`, `school` 엔티티가 존재.
      * 영속성 전이를 하고 싶으면 `child` 객체는 `parent`만 필드로 가지고 있어야 함.
      * 만약 `school`애서 `child`를 필드로 가진다면 오류 발생. => `child`를 필드로 가지는 엔티티가 유일해야 전이 가능.  
        (**결론 : 단일 엔티티에 종속적이여야 한다.**)
      * 단, `child`에서는 어느 객체라도 필드를 가져도 상관 없음.


## CASCADE 종류
* ALL : 모두 적용 (전부 LifeCycle을 맞추어야 할 때)
* PERSIST : 영속 (저장할 떄만 사용)
* REMOVE : 삭제
* MERGE
* REFRESH
* DETACH

***

# 고아 객체
* 부모 엔티티와 **연관관계가 끊어진 자식 엔티티를 자동으로 삭제**
* 매핑 어노테이션에 `orphanRemoval = true` 추가
  * ```java
      @OneToMany(mappedBy = "parent", orphanRemoval = true)
      private List<Child> childList = new ArrayList<>();
    ```

* `parent.getChildren().remove()` 시 `DELETE` 쿼리가 나감.

  ```java
              Child child1 = new Child();
              Child child2 = new Child();
  
              Parent parent = new Parent();
              parent.addChild(child1);
              parent.addChild(child2);
  
              em.persist(parent);
  
              em.flush();
              em.clear();
  
              Parent findParent = em.find(Parent.class, parent.getId());
              findParent.getChildList().remove(0);
  
              transaction.commit();
  ```
  
## 주의사항
* 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능

* 영속성 전이와 마찬가지로 **참조하는 곳이 하나일 때 사용해야 한다.**  
  (= 특정 엔티티가 개인 소유할 때 사용. `@OneToOne`, `@OneToMany`만 가능)
  

# 영속성 전이 + 고아 객체
```java
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Child> childList = new ArrayList<>();
```
이렇게 `영속성 전이`와 `고아 객체`를 모두 적용하면 어떤 일이 일어날까?

* 스스로 생명주기를 관리하는 엔티티는 `em.persist()`로 영속화, `em.remove()`로 제거
* **부모 엔티티를 통해서 자식의 `생명 주기`를 관리할 수 있다.**
  * parent만 `persist`하고, `remove`를 해도, `child`에게 영향이 간다.
* 도메인 주도 설계의 `Aggregate Root`개념을 구현할때 유용하다.
