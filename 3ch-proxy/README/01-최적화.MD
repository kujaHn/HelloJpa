# 최적화
임의의 멤버와 그가 속한 팀의 정보를 출력하는 로직인 `printMemberAndTeam` 가 있다.  
그런데 특정한 상황에는 팀 정보 없이 멤버의 정보만 필요한 `printMember` 로직만 필요하다 치자.  
우리가 필요한 정보는 `Member`이나 이 엔티티는 `Team`과 연관관계가 있다. 그래서 `Member`을 가져오면 `Team`도 같이 딸려오게 되어  
불필요한 자원을 소모하게 된다.(최적화가 안됨.)  
그렇다면 **이것이 JPA의 한계인가? 당연히 그렇지 않다.** JPA는 `프록시`와 `지연로딩`으로 이러한 문제를 해결한다.

## 프록시
우리가 이때까지 엔티티의 정보를 가져올때 사용한 메소드는 `EntityManger.find()`였다.  
하지만 이번장에서는 `EntityManger.getReference()`을 다루게 될 것이다.  
먼저 대략적인 차이점부터 살펴보자.

* `find()` : DB를 통해서 `실제 엔티티 객체` 조회 => DB에 쿼리가 나감.
* `getReference()` : DB 조회를 미루는 `가짜(프록시) 엔티티 객체` 조회 => DB에 쿼리가 안나감.

### 프록시 특징
* 프록시 객체는 처음 사용할 때 `한 번만 초기화` => 다음 요청부터는 그 객체를 계속해서 사용.
* 프록시 객체를 초기화할때, **프록시 객체가 실제 엔티티로 바뀌는 것이 아니다!!!**  why?  
  프록시 객체는 원본 엔티티를 상속받기 떄문. (타입 비교시 주의. `==` 비교 불가능, `instance of` 사용해야함.)
* 영속성 컨텍스트에 이미 찾는 엔티티가 있으면 `getReference()`를 호출해도 실제 엔티티를 반환. (반대도 같음)
* 영속성 컨텍스트의 도움을 받을 수 없는 `준영속 상태`일때, **프록시를 초기화하면 문제 발생.**


### 프록시 작동원리
* 프록시 객체가 `영속성 컨텍스트`에 `진짜 객체(실제 엔티티)`를 가져오라고 `초기화 요청`을 함.
* `영속성 컨텍스트`는 요청을 받아 DB에 조회 후 `실제 엔티티`를 생성함. `org.hibernate.LazyInitializationException`를 터트림

### 프록시 확인
* 프록시 인스턴스의 초기화 여부 확인 (`EntityManagerFactory`에서 기능 부여)  
`emf.PersistenceUnitUtil.isLoaded(Object entity)`
  
* 프록시 클래스 확인 방법 :`entity.getClass().getName()`출력.
* 프록시 강제 초기화 : `org.hibernate.Hibernate.initialize(entity)` Hibernate에서 제공
  * JPA 표준은 강제 초기화가 없다. (강제 호출밖에 답이 없음. `ex: member.getName()`)
  
## 즉시로딩과 지연로딩 (fetch strategy)
매핑에서 `fetch`를 통해 `즉시로딩`과 `지연로딩`을 정할 수 있다.

### 지연로딩
* 비즈니스 로직을 설계할 때 연관관계 매핑된 엔티티들이 같이 쓰이지 않고 **따로 쓰이는 경우가 많을때 실시.**  
  => 내가 필요한 데이터만 가지고 나올 수 있다.  
* 연관관계 매핑(`@ManyToOne` `@OneToMany`등등)에 `fetch = FetchType.LAZY`를 통해 구현.
  

* 예시로 `Member.class`에서 `Team`을 `지연로딩`을 실시해 보자.
  ```java
      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn
      private Team team;
  ```
  
  ```java
  Member member = em.find(Member.class, 1L) // 1.
  Team team = member.getTeam();             // 2.
  team.getName();                           // 3.
  ```  
1. `Member객체만 실제 엔티티 객체`이고 `Team이 프록시 객체`이다. (Member `SELECT` 쿼리 실행)
2. `Team`을 가져올때도 역시 `프록시 객체`
3. 실제 **Team을 사용하는 시점**에 `초기화`. (Team `SELECT`쿼리 실행.)

* 이렇게 쿼리가 **초기화를 할 시점마다 따로 나가기 때문**에 연관관계 엔티티들이 **같이 쓰이는 경우가 많이 없을때 쓰면 유리**하다.

### 즉시로딩
* 비즈니스 로직을 설계할 때 연관관계 매핑된 엔티티들이 **같이 쓰이는 경우가 많은 경우 지연로딩은 오히려 손해.**  
  => `SELECT` 쿼리가 여러번 나가기 때문!
* 연관관계 매핑(`@ManyToOne` `@OneToMany`등등)에 `fetch = FetchType.EAGER`를 통해 구현.

* 예시로 `Member.class`에서 `Team`을 `즉시로딩`을 실시해 보자.
  ```java
      @ManyToOne(fetch = FetchType.EAGER)
      @JoinColumn
      private Team team;
  ```

  ```java
  Member member = em.find(Member.class, 1L) // 1.
  Team team = member.getTeam();             // 2.
  team.getName();                           // 3.
  ```  
1. `Member와 Team` 모두 `실제 엔티티 객체`.

### 지연로딩 vs 즉시로딩
* **가급적 지연로딩만 사용 (특히 실무에서)**
  * 즉시 로딩은 예상치 못한 SQL이 발생한다. : **연관관계 매핑이 복잡한 경우** 검색할 테이블에 관련된 모든 테이블이 `Join`되어 가져 올 수 있다.
  * 즉시 로딩은 JPQL에서 1+N 문제를 일으킨다.  
    * 연관되어있는 테이블에 연관된 데이터 수 만큼(N) 또 SQL문을 호출해야 함.
    * 결국 최초쿼리 (1) + 연관된 데이터 수(N)만큼 호출을 해야함.  
    
  * `@ManyToOne` `@OneToOne`은 기본이 `즉시로딩` => `지연로딩`으로 설정.
  

* `JPQL fetch 조인`이나, `엔티티 그래프` 기능을 사용.
