# 영속성
JPA에서 가장 중요한 것은 바로 `객체와 관계형 데이터베이스 간 매핑`과 `영속성 관리`이다.  
이번 시간은 `영속성 관리`에 대해 알아보자.  

## 엔티티 매니저 팩토리와 엔티티 매니저 복습

기본적인 로직은 다음과 같다.  
* `엔티티 매니저 팩토리` 생성
* 고객의 요청이 올때마다 `엔티티 매니저 팩토리`가 `엔티티 매니저` 생성.
* DB 연결이 꼭 필요한 시점에 커넥션 획득 후 비즈니스 로직 실행.
* 실행이 완료되면 `close`를 통해 해당 엔티티 매니저를 **버림.**
  * 다시 한번 말하지만 `엔티티 매니저 팩토리`는 여러 스레드가 동시에 접근해도 안전해서 공유가 가능하지만,
  * `엔티티 매니저`는 여러 스레드가 동시에 접근하면 `동시성 문제`가 발생하므로 **스레드 간에 절대 공유하면 안 된다.**


## 영속성 컨텍스트
* JPA를 이해하는데 가장 중요한 용어
* 말 그대로 `엔티티를 영구 저장하는 환경`이라는 뜻
* `EntityManager.persist(entity)`
  * `persist()` 메소드를 통해 `엔티티 매니저`가 **`영속성 컨텍스트`에 `엔티티`를 저장하고 관리.**

### 1. 엔티티의 생성주기
엔티티의 생명주기는 4가지 상태로 존재한다.
* 비영속(new/transient) :`영속성 컨텍스트`와 전혀 관계가 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제(removed) : 삭제된 상태

***

### 1) 비영속
엔티티 객체를 **생성만** 해서 `영속성 컨텍스트`나 `DB`에 전혀 관련이 없는 상태.  
![image](https://user-images.githubusercontent.com/72388950/112258949-b8577380-8caa-11eb-9c10-599858f9caff.png)

```java
// 객체만 생성
Member newMember = new Member();
newMember.setId(1L);
newMember.setName("MemberA);
```

***

### 2) 영속
엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장해 **`영속성 컨텍스트`에 의해 관리되는 것을 `영속상태`** 라고 함.  
이때 식별자 값(`PK값, @Id`)이 반드시 있어야 한다.(없을 시 예외발생)
![image](https://user-images.githubusercontent.com/72388950/112259229-44699b00-8cab-11eb-8b78-c26e6e12e1b7.png)  
```java
EntityManager em = emf.createEntityManager();
em.getTransaction() = em.getTransaction();
// 객체 영속
em.persist(newMember)
```
<br>

***

### 3) 준영속
* 영속 상태의 엔티티가 영속성 컨텍스트에서 **분리된 상태.** (거의 비영속에 가까움.)
* 비영속 상태와 달리 이미 한 번 영속상태였으므로 **반드시 `식별자 값`을 가지고 있음.**
* **지연 로딩을 할 수 없다.**


* 준영속 상태로 만드는 방법

#### em.detach(entity) : 특정 엔티티만 준영속 상태로 전환 `DetachJpa.class`
     ```java
      Member newMember = new Member();
      newMember.setId(45L);
      newMember.setName("detachTest");
      em.persist(newMember);

      // 준영속 상태로 전환
      em.detach(newMember);

      transaction.commit();
     ```
     
     * `1차 캐시`부터 `쓰기지연 SQL 저장소` 까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됨.
     * 영속성 컨텍스트가 지원하는 어떤 기능도 동작하지 않음.
     * 
#### em.clear() : 해당 영속성 컨텍스트를 완전히 초기화해서 모든 엔티티를 준영속상태로 만듬. `CLearJpa.class`
    ```java
    Member findMember1 = em.find(Member.class, 43L);
    findMember1.setName("AAAAA");
    
    // 1차 캐시 clear
    em.clear();
    
    Member findMember2 = em.find(Member.class, 43L);
    transaction.commit();
    ```
    * 커밋 전에 clear()을 했기 때문에 setName("AAAAA")는 적용이 안된다.
    * 모두 1차 캐시를 초기화한다고 생각해도 무방하다.
#### em.close() : 영속성 컨텍스트를 종료


### 번외 : 준영속에서 다시 영속상태로 전환하는 `merge()`
 * `merge()`는 준영속 상태의 엔티티를 받아서 **새로운 영속 상태의 엔티티를 반환**한다. (비영속도 가능하다.)
  ![image](https://user-images.githubusercontent.com/72388950/113276700-10315280-931b-11eb-9d27-626629ba5509.png)
  * `Member mergeMember = em.merge(member);` 이라면 `member`은 영속상태가 아니고, `mergeMember`은 영속상태가 된다.
   * 과정
   1. `merge()`실행.
   2. 파라미터의 값으로 넘어온 준영속 엔티티의 `식별자 값`으로 1차캐시에서 엔티티를 조회. (**1차캐시에 엔티티가 없으면 DB에서 조회**)
   3. 새로운 영속 엔티티 `mergeMember`에 `member`엔티티의  모든 값들을 밀어 넣는다.
   4. `mergeMember`을 반환한다.



### 2. 영속성 컨텍스트가 엔티티를 관리할때의 이점

### 1) 1차 캐시
임의의 Member 엔티티를 생성을 하고 영속을 해보자 그 후 식별자 값을 통해 조회(`find()`)를 실시하는 `CacheJpa.class`를 만들자.
```java
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();

        EntityTransaction transaction = em.getTransaction();
        transaction.begin();

        //비영속 상태
        Member newMember = new Member();
        newMember.setId(101L);
        newMember.setName("1차캐시테스트");

        //영속 상태
        em.persist(newMember);

        Member findMember = em.find(Member.class, 101L);
        System.out.println("findMember = " + findMember);

        transaction.commit();

        em.close();
        emf.close();
    }
```
* 결과  
![image](https://user-images.githubusercontent.com/72388950/112262084-64e82400-8cb0-11eb-9fc9-2c0f1b4c5939.png)  
어느곳에서도 SELECT를 찾아 볼 수 없다. 하지만 성공적으로 find를 수행한 것을 볼 수 있다. 이걸 가능케 하는 것이 `1차캐시` 이다.  
<br>
![image](https://user-images.githubusercontent.com/72388950/112262219-a4af0b80-8cb0-11eb-83df-bf74060be031.png)    
* 영속성 컨텍스트는 내부에 캐시를 가지고 있다. 이를 `1차 캐시`라고 하는데 **영속상태의 엔티티는 모두 이곳에 저장된다.**
  * `Map<@Id로 매핑한 식별자, member인스턴스>`가 영속성 컨텍스트 내부에 있다라고 생각하자
* `find()`를 호출해서 우선적으로 `1차 캐시`에서 **엔티티를 찾고**, 여기에 없으면 `데이터베이스`에서 조회한다. 
  * 1차캐시에 있으면 그대로 반환, 없으면 DB에서 조회를 해 **1차캐시에 저장 한 후 반환**
* 드라마틱한 성능이점을 기대하기 어렵지만 **한 데이터를 여러번 불러야 하는 복잡한 로직에서는 성능 이점을 볼 수 있다.**

***

### 2) 동일성 보장
같은 데이터를 찾는 코드를 구현하고 이 결과를 출력을 해 보자
```java
        Member findMember1 = em.find(Member.class, 101L);
        Member findMember2 = em.find(Member.class, 101L);

        System.out.println("result = " + (findMember1==findMember2));
```
이 결과는 `result = true` 이 출력이 된다. 이는 1차 캐시에 있는 **같은 엔티티 인스턴스를 반환하기 떄문이다.**  
**1차캐시가 있기 때문에 동일성이 보장이 된다는 것을 알 수 있다.**
  
<br>

***

#### 3) 트랜잭션을 지원하는 쓰기 지연과 지연 로딩
 #### (1) 쓰기지연
  `쓰기 지연`은 `쓰기지연 SQL 저장소`에 한번에 모아뒀다가 `commit`을 하는 시점에 한꺼번에 처리를 하는 기능이다.  
  ![image](https://user-images.githubusercontent.com/72388950/112276772-70dde100-8cc4-11eb-9c7e-0cf48bdc028d.png)  

  * 한꺼번에 commit  
  ![image](https://user-images.githubusercontent.com/72388950/112276839-818e5700-8cc4-11eb-8c8d-25240950d4bc.png)  

  * `버퍼링` 기능을 사용 할 수 있다. => `최적화`가 가능하다. (`batch`)

 #### (2) 지연로딩

  * **실제 객체 대신 `프록시 객체`를 로딩**해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법. 



***

#### 4) 변경 감지 (더티 체킹)
`1장 업데이트 기능`의 연장선이다. **데이터를 저장할 필요 없이 데이터 변화를 감지하여 `update`쿼리를 자동으로 생성해 실행 해 준다** 라고 했었다.
비밀은 `영속 컨텍스트`안에 있다.  
  
![image](https://user-images.githubusercontent.com/72388950/112279276-198d4000-8cc7-11eb-9a78-1dbd17332de0.png)  
  
1. 트랜젝션을 커밋하면 엔티티 매니저 내부에서 `flush()` 호출 [transaction.begin()]
2. 엔티티와 `스냅샷` 비교
    * 엔티티를 영속성 컨텍스트에 최초로 보관(1차캐시에 `최초`로 저장)할 때 스냅샷을 찍어둔다.
3. 변경된 엔티티가 있는 경우 `update` 쿼리를 생성해서 `쓰기 지연 SQL 저장소`에 보낸다.
4. `쓰기 지연 SQL 저장소`의 SQL을 DB에 보낸다
5. DB 트랜젝션을 커밋한다. [transaction.commit()]

* `변경감지의 update`와 `merge()에서의 update` 정도의 차이를 유념해야 한다.
 * 변경감지 : 내가 원하는 파라미터만 바꿀 수 있음
 * merge : 내가 원하든 원하지않든 모든 파라미터가 바뀜. 


* **플러시**
* 영속성 컨텍스트의 변경내용을 데이터베이스에 반영. (`DB transaction`이 `commit`되면 발생) 
* 플러시의 구동
  * 변경 감지 동작
  * 수정된 엔티티를 `쓰기 지연 SQL 저장소`에 등록
  * `쓰기 지연 SQL 저장소`의 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)
* 영속성 컨텍스트를 플러시 하는 방법
  * 직접호출 : `em.flush()`
    * `commit`전에 DB에 `선반영` 하고 싶을 때 강제 호출 용도로 쓰인다. (보통 테스트할 때 쓰임)
  * 자동호출 : `트랜젝션 커밋` 또는 `JPQL 쿼리 실행`
    * 트랜젝션 커밋
      * DB 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 DB에 반영되지 않는다.
      * 꼭 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 DB에 반영해야 함.
    
    * JPQL 쿼리 실행 시 `flush`가 자동호출 되는 이유
      ```java
      em.persist(memberA);
      em.persist(memberB);
      em.persist(memberC);
      
      //중간에 JPQL 실행
      query = em.createQuery("select m from Member m", Member.class);
      List<Member> members = query.getResultList();
      ```
      이런 경우 `JPQL`실행 시 `memberA~memberC`가 반영이 안될 것이다.  
      이런 상황을 방지하고자 JPA에서는 JPQL을 실행 시 자동으로 `flush`을 날린다.  
* 명심할 점
  * 영속성 컨텍스트를 비우는 것이 아님. (`동기화`라고 생각하자!)
  * 트랜잭션이라는 작업 단위가 중요함 -> 커밋 직전에만 동기화를 하면 됨.
  * 식별자를 기준으로 조회하는 `find()`는 플러시가 실행되지 않는다.
