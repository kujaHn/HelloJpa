# 등장배경
* JPA를 사용하면 엔티티 객체를 중심으로 개발을 함.
* 문제는 검색쿼리
    * 검색을 할 때 테이블이 아닌 엔티티 객체를 대상으로 검색을 해야함
    * 하지만 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능하다.
    * 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요하다.

# JPQL   
* JPA는 SQL을 추상화한 JPQL이라는 `객체 지향 쿼리 언어` 제공
* SQL과 문법 유사 (ANSI SQL 표준)
* 엔티티 객체를 대상으로 쿼리 (기존 SQL은 테이블을 대상으로 쿼리)

`ch1.JpqlMain.class` 참고
```java
List<Member> members = em.createQuery("SELECT m from  Member where m.name like '%kim%'", Member.class)
        .getResultList();
```
## 단점
* JPQL의 쿼리는 단순 `String`타입이다. 그말인즉슨 `동적쿼리`가 어렵다는 말이다.
* 이로 인해 `Criteria`가 만들어졌다.

# JPQL Criteria
* JPA 표준 스펙
* 문자가 아닌 `자바코드`로 JPQL을 작성할 수 있다. => `동적쿼리 설계`를 쉽게 할 수 있다.

`ch1.CriteriaMain.class` 참고
```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

Root<Member> m = query.from(Member.class);

CriteriaQuery<Member> cq = query.select(m);

String username = "park";
if (username != null) {
    cq = cq.where(cb.equal(m.get("username"), "kim"));
}
List<Member> members = em.createQuery(cq).getResultList();

```
## 단점
* SQL같이 보이지 않아서 유지보수가 어렵고 난이도가 높다. + 너무 복잡하다

# QueryDSL
* `Criteria`의 장점을 가져오면서, 단점도 커버가 가능하다.
* 컴파일 시점에 문법 오류를찾을 수 있다.
* 실무 사용 권장

`ch1.DslMain.class`참고
```java
QMember m = QMember.member;
List<Member> result = queryFactory
        .select(m)
        .from(m)
        .where(m.name.like("kim"))
        .fetch();
```

# 네이티브 SQL
* JPA가 제공하는 SQL을 직접 사용하는 기능
* JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 (ex: 오라클의 `CONNECT BY`, 특정 DB만 사용하는 SQL 힌트)
  * 이 기능은 DB방언 세팅을 이용해서 해결할 수도 있다.
```java
List<Member> members = em.createNativeQuery("SELECT * FROM Member")
        .getResultList();
```

# JDBC 직접 사용
* JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, MyBatis 등을 함께 사용 가능.
* 단 영속성 컨텍스트를 적절한 시점에 강제로 `플러시`가 필요
  * JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시.
  

## 정리
* JPQL의 기본문법은 철저히 익혀야 한다
* 추후 동적쿼리 설계를 위해 `QueryDSL`의 사용을 익히자.
* 정말 복잡한 동적쿼리는 `SpringJdbcTemplate`와 `MyBatis`를 이용하자.